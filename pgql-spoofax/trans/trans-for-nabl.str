module trans-for-nabl

imports

  stratego/-
  signatures/-
  normalized-signatures
  common
  pp
  runtime/index/-
  runtime/nabl/-
  runtime/properties/-
  runtime/types/-
  runtime/task/-
  runtime/analysis/-
  runtime/editor/-
  names/-

/*
 * 'trans-for-nabl' is called after 'normalize' and transforms the normalized AST into a shape that works for NaBL.
 *
 *  PGQL String -> PGQL AST -> PGQL normalized AST -> PGQL AST for NaBL -> GraphQuery object -> query plan
 */
rules

  trans-for-nabl = trans-query(|[])
                   + ?Start-Plhdr() // for empty query string

rules

  trans-query(|variables):
    NormalizedQuery(CommonPathExpressions(pathExpressions), selectOrModifyClause, optionalGraphName, graphPattern, groupBy, having, orderBy, limitOffsets, error-messages, version) ->
        NormalizedQuery(CommonPathExpressions(pathExpressions'), selectOrModifyClause', optionalGraphName, graphPattern', groupBy', having', orderBy', limitOffsets, error-messages, version)
    with variables' := <guarantee-size-two-or-more> variables

       // PATH
       ; pathExpressions' := <map(trans-path-expression(|variables'))> pathExpressions

       // only in PGQL 1.3 and up, column names specified in the SELECT clause are visible in GROUP BY, HAVING and ORDER BY (but only outside of aggregations and subqueries)
       ; expAsVars := <(?"v1.0" + ?"v1.1"); ![] <+ !selectOrModifyClause; ?SelectClause(_, ExpAsVars(<id>)) <+ ![]> version

       ; if <?Some(GraphPattern(vertices, connections, valueExpression))> := graphPattern
         then // MATCH
              (vertices', connections') := <alltd(trans-elem(|variables'))> (vertices, connections)
              ; edges := <filter(?Edge(_, _, _, _, _, _) + path-with-at-most-one-binding)> connections'
              ; paths := <filter(path-with-two-or-more-bindings)> connections'

              ; new-vars := <collect(to-varDef)> (vertices', edges)
              ; new-groupVars := <collect(to-varDef)> paths
              ; <?[x|[y|ys]]> variables'
              ; visible-vars := <replace-or-add-all> (new-vars, x)
              ; visible-groupVars := <replace-or-add-all> (new-groupVars, y)
              ; variables'' := [visible-vars|[visible-groupVars|ys]]

             ; connections'' := <alltd(resolve-var-refs-in-path-expression(|variables''))> connections'
       
              // WHERE
              ; valueExpression' := <resolve-where-clause(|variables'', expAsVars)> valueExpression

              ; graphPattern' := Some(GraphPattern(vertices', connections'', valueExpression'))
         else graphPattern' := None()
            ; variables'' := variables'
         end

       // GROUP BY
       ; if (!groupBy; ?Some(_)) + (!selectOrModifyClause; create-one-group(|variables'')) + (!having; ?Some(_))
         then hasGroupBy := True()
            ; (groupBy', variables''') := <resolve-group-by(|variables'', expAsVars)> groupBy
         else hasGroupBy := False()
            ; (groupBy', variables''') := (groupBy, variables'')
         end

       // SELECT / MODIFY
       ; (selectOrModifyClause', variables'''') := <resolve-select-or-modify-clause(|variables''')> selectOrModifyClause

       // HAVING
       ; having' := <resolve-having(|variables''', variables'''')> having // having resolves to GROUP BY variables first, then to SELECT variables

       // ORDER BY
       ; orderBy' := <resolve-prop-refs(|variables'''); resolve-var-refs(|variables''''); alltd(optimize-order-by)> orderBy // ORDER BY resolves to SELECT variables first, then to GROUP BY variables (except in case of a VarRef in a PropRef, in which case it is resolved to MATCH or GROUP BY first)

  path-with-at-most-one-binding:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where <has-at-most-one-binding> quantifier

  path-with-two-or-more-bindings:
    t@Path(_, _, _, quantifier, _, _, _, _) -> t
    where not( <has-at-most-one-binding> quantifier )

  guarantee-size-two-or-more = ?[]; ![[], []] <+ ?[x]; ![x, []] <+ id

  trans-elem(|variables):
    Vertex(v) -> Vertex(v, origin-offset, correlation)
    with origin-offset := <origin-offset> v
       ; correlation := <to-Correlation(|variables)> v

  trans-elem(|variables):
    NormalizedEdge(src, e, dst, direction, _, _) -> Edge(src, e, dst, direction, origin-offset, correlation)
    with origin-offset := <origin-offset> e
       ; correlation := <to-Correlation(|variables)> e

  to-Correlation(|variables):
    v -> correlation
    with if <oncetd(?VarDef(v, _, _, _, _); ?VarDef(v-from-outer-query, origin-position-from-outer-query, _, _, _))> variables
         then correlation := Correlation(VarRef(v-from-outer-query, origin-position-from-outer-query))
         else correlation := None()
         end

  to-varDef = ?Vertex(name, origin-offset, _); !VarDef(name, origin-offset, None(), None(), False())
  to-varDef = ?Edge(_, name, _, _, origin-offset, _); !VarDef(name, origin-offset, None(), None(), False())

  replace-or-add-all = foldl(replace-or-add)

  replace-or-add:
    (vd@VarDef(v, _, _, _, _), varDefs) -> varDefs'
    with if <fetch(?VarDef(v, _, _, _, _))> varDefs
         then varDefs' := <conc> (<remove-all(?VarDef(v, _, _, _, _))> varDefs, [vd])
         else varDefs' := <conc> (varDefs, [vd])
         end

  resolve-where-clause(|variables, expAsVars):
    valueExpression -> valueExpression'
    with valueExpression' := <resolve-var-refs(|variables, expAsVars)> valueExpression

  resolve-group-by(|variables, expAsVarsFromSelectClause):
    Some(GroupByClause(expAsVars)) -> (Some(GroupByClause(expAsVars')), variables')
    with (expAsVars', vars') := <foldl(resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause))> (expAsVars, ([], []))
       ; variables' := [vars'|variables]

  resolve-group-by(|variables, expAsVars):
    None() -> (CreateOneGroup(), variables')
    with vars' := []
       ; variables' := [vars'|variables]

  resolve-select-or-modify-clause(|variables):
    SelectClause(distinct, eav@ExpAsVars(expAsVars)) -> (SelectClause(distinct, eav'), variables')
    with if Star() := expAsVars
         then eav' := expAsVars
            ; variables':= variables
         else varsInCurrentScope := <Hd> variables
            ; (expAsVars', vars') := <foldl(resolve-exp-as-var-in-select(|variables))> (expAsVars, ([], varsInCurrentScope))
            ; eav' := <origin-track-forced(!ExpAsVars(expAsVars'))> eav
            ; variables' := [vars'|<Tl> variables]
         end

  resolve-select-or-modify-clause(|variables):
    t@ModifyClause(graphName, modifications) -> (modifyClause', variables')
    with varsInCurrentScope := <Hd> variables
       ; (modifications', variables') := <foldl(resolve-modification)> (modifications, ([], variables))
       ; modifyClause' := <origin-track-forced(!ModifyClause(graphName, modifications'))> t

  resolve-modification:
    (modification, (result, variables)) -> (result', variables')
    with varsInCurrentScope := <Hd> variables
       ; (modification', varsInCurrentScope') := <create-variable-for-insertion(|varsInCurrentScope)> modification
       ; variables' := [varsInCurrentScope'|<Tl> variables]
       ; modification'' := <resolve-var-refs(|variables')> modification'
       ; result' := <conc> (result, [modification''])

  create-variable-for-insertion(|vars):
    t@DirectedEdgeInsertion(_, Identifier(v), src, dst, labels, properties) -> (insertion', vars')
    with originOffset := <origin-offset> v
       ; insertion' := <origin-track-forced(!DirectedEdgeInsertion(v, originOffset, src, dst, labels, properties))> t
       ; vars' := <replace-or-add> (VarDef(v, originOffset, None(), None(), ThisQuery()), vars)

  create-variable-for-insertion(|vars):
    t@VertexInsertion(Identifier(v), labels, properties) -> (insertion', vars')
    with originOffset := <origin-offset> v
       ; insertion' := <origin-track-forced(!VertexInsertion(v, <origin-offset> v, labels, properties))> t
       ; vars' := <replace-or-add> (VarDef(v, originOffset, None(), None(), ThisQuery()), vars)

  create-variable-for-insertion(|vars):
    t@Update(_, _) -> (t, vars) // just pass through

  create-variable-for-insertion(|vars):
    t@Deletion(_) -> (t, vars) // just pass through

  resolve-exp-as-var-in-group-by(|variables, expAsVarsFromSelectClause):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables, expAsVarsFromSelectClause)> exp
       ; exp'' := <alltd(?VarRef(<id>, _); !VarRef(<id>))> exp'
       ; originOffset := <origin-offset> v
       ; vars' := <replace-or-add> (VarDef(v, originOffset, exp'', exp', ThisQuery()), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, originOffset))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-exp-as-var-in-select(|variables):
    (t@ExpAsVar(exp, v, anonymous), (result, vars)) -> (result', vars')
    with exp' := <resolve-var-refs(|variables)> exp
       ; originOffset := <origin-offset> v
       ; if <?Anonymous(); !v; origin-text; ?"*"> anonymous
         then // in case of SELECT * make sure each ExpAsVar gets a unique origin assigned
              unique-origin := <conc-strings> ("*_", <write-to-string> originOffset, "_", <write-to-string> v)
         else unique-origin := originOffset
         end
       ; vars' := <replace-or-add> (VarDef(v, unique-origin, exp, exp', ThisQuery()), vars)
       ; expAsVar' := <origin-track-forced(!ExpAsVar(exp', v, anonymous, unique-origin))> t
       ; result' := <conc> (result, [expAsVar'])

  resolve-having(|variables-after-group-by, variables-after-select):
    having -> having'
    with [x|xs] := variables-after-select
       ; [y|_] := variables-after-group-by
       ; z := <replace-or-add-all> (y, x)
       ; variables := [z|xs]
       ; having' := <resolve-var-refs(|variables)> having

  /*
     First try to resolve variables as usual.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) -> (m) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the MATCH clause.
     Only if it fails, try to replace variables with expressions from SELECT before trying to resolve again.
     For example, in "SELECT n.prop AS m FROM MATCH( (n) ) WHERE m.prop = 123", the "m" in the WHERE clause should reference the "m" in the SELECT clause.
     Note that in the final AST, we only want the SELECT to refer to variables in GROUP BY, even though for the user it typically appears like it's the other way arround.
     For example:
        Actual query: SELECT n.age + 2 FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT (n.age + 2)*(n.age + 2) FROM MATCH( (n) ) GROUP BY n.age + 2
        Final AST:    SELECT generatedVar*generatedVar FROM MATCH( (n) ) GROUP BY n.age + 2 AS generatedVar
     For example:
        Actual query: SELECT n.age + 2 AS v FROM MATCH( (n) ) GROUP BY v
        Final AST:    SELECT v FROM MATCH( (n) ) GROUP BY n.age + 2 AS v
  */
  resolve-var-refs(|variables, expAsVarsFromSelectClause) =
    resolve-var-refs(|variables)
  ; alltd-in-outer-query-outside-aggregation(replace-ref-with-exp(|expAsVarsFromSelectClause))
  ; alltd-in-outer-query-outside-aggregation(resolve-var-ref(|variables))

  resolve-var-refs(|variables) = alltd(resolve-var-ref(|variables))
                               ; alltd(replace-exp-with-ref-within-this-query(|variables) <+ is-subquery <+ is-aggregate)
                               ; alltd(replace-exp-with-ref-from-outer-queries(|variables) <+ is-subquery <+ is-aggregate)

  resolve-var-refs-in-path-expression(|variables):
    t@Path(_, _, _, quantifier, _, _, _, _) -> t'
    with [_|variables'] := variables
       ; if <has-at-most-one-binding> quantifier
       then t' := <alltd(resolve-var-ref(|variables))> t // resolve only to singleton variables
       else t' := <alltd(resolve-var-ref(|variables') + resolve-var-ref(|variables))> t // resolve to either group variables or singleton variables
        end

  resolve-var-ref(|variables):
    t@VarRef(v) -> varRef
    with varRef := <
        Hd; fetch(?VarDef(v, origin-offset, _, _, _)); !VarRef(v, origin-offset)
        <+ !VarRef(v)
      > variables

  // MIN, MAX, SUM, AVG, ...
  resolve-var-ref(|variables):
    aggr -> <origin-track-forced(!aggr')> aggr
    where <is-aggregate> aggr
    with (cons, arguments) := <explode-term> aggr
       ; variables' := <Tl> variables
       ; arguments' :=  <resolve-var-refs(|variables')> arguments
       ; aggr' := <mkterm> (cons, arguments')

  resolve-var-ref(|variables):
    Subquery(query) -> Subquery(query')
    with variables' := <alltd(VarDef(id, id, id, id, !OuterQuery()))> variables
       ; query' := <trans-query(|variables')> query

  replace-exp-with-ref-within-this-query(|variables):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <Hd; filter(?VarDef(_, _, _, _, ThisQuery())); fetch-elem(replace-unresolved-exp-with-ref(|exp) + replace-resolved-exp-with-ref-helper(|exp))> variables

  replace-exp-with-ref-from-outer-queries(|variables):
    exp -> varRef
    where not ( None() := exp )
        ; varRef := <Hd; filter(?VarDef(_, _, _, _, OuterQuery())); fetch-elem(replace-unresolved-exp-with-ref(|exp))> variables

  /*
     When the expression could not be resolved, but there is an equivalent expression that we can replace it with.
     For example:
       Actual query: SELECT n.age FROM g MATCH (n) GROUP BY n.age
       Final AST:    SELECT generatedVar FROM g MATCH (n) GROUP BY n.age AS generatedVar
  */
  replace-unresolved-exp-with-ref(|exp) = ?VarDef(v, origin-offset, original-exp, _, _); where ( <eq> (exp, original-exp) ); !VarRef(v, origin-offset)

  /*
     When the expression was resolved succesfully, but there is an equivalent expression that we can replace it with.
     For example:
       Actual query: SELECT n.age AS nAge FROM g MATCH (n) ORDER BY n.age
       Final AST:    SELECT n.age AS nAge FROM g MATCH (n) ORDER BY nAge
  */
  replace-resolved-exp-with-ref-helper(|exp) = ?VarDef(v, origin-offset, _, resolved-exp, _); where ( <eq> (exp, resolved-exp) ); !VarRef(v, origin-offset)

  replace-ref-with-exp(|expAsVars):
    VarRef(v) -> exp
    where ExpAsVar(exp, _, _) := <filter(?ExpAsVar(_, v, NonAnonymous())); Hd> expAsVars

  resolve-prop-refs(|variables) = alltd(resolve-prop-ref(|variables))

  resolve-prop-ref(|variables):
    t@PropRef(varRef, prop) -> PropRef(varRef', prop)
    with varRef' := <resolve-var-ref(|variables)> varRef

  /*
     if the query has no GROUP BY but there are one ore more aggregations in the SELECT, then we generate an
     implicit group, but only if there is no (non-nested) aggregation over a group variable
  */
  create-one-group(|variables):
    t@select-or-modify-clause -> t
    with [vars|[groupVars|_]] := variables
       ; aggregations := <collect-in-outer-query(is-aggregate)> select-or-modify-clause
       ; exps-from-aggregations := <collect(get-exp-from-aggregation)> select-or-modify-clause
       ; varsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|vars))> exps-from-aggregations
       ; groupVarsInAggregations := <collect-in-outer-query-outside-aggregation(varRef-is-visible-var(|groupVars))> exps-from-aggregations
       ; groupVarsInAggregations' := <diff> (groupVarsInAggregations, varsInAggregations)
    where not ( [] := aggregations ) // there are aggregations
        ; [] := groupVarsInAggregations' // but no aggregations that involve group variables (not counting nested aggregations)

  varRef-is-visible-var(|visible-vars):
    t@VarRef(v) -> t
    where <oncetd(?VarDef(v, _, _, _, _))> visible-vars

  trans-path-expression(|variables):
    CommonPathExpression(name, vertices, edges, valueExpression) -> CommonPathExpression(name, vertices', edges', valueExpression')
    with
       // pattern
        (vertices', edges') := <alltd(trans-elem(|variables))> (vertices, edges)
       ; new-vars := <collect(to-varDef)> (vertices', edges')
       ; <?[x|xs]> variables
       ; visible-vars := <replace-or-add-all> (new-vars, x)

       // WHERE
       ; variables' := [visible-vars|xs]
       ; valueExpression' := <resolve-where-clause(|variables', [])> valueExpression

  optimize-order-by:
    OrderByClause(elems) -> OrderByClause(elems')
    with elems' := <make-set-while-preserving-ordering> elems // optimization to translate e.g. ORDER BY x, y, x, y into ORDER BY x, y
